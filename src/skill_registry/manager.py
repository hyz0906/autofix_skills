"""
Skill Registry and BaseSkill definition.

This module defines the abstract BaseSkill interface and the SkillManager
which is responsible for loading, indexing, and retrieving skills.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any, Dict, List, Optional, Type

from src.utils.logger import get_logger

logger = get_logger(__name__)


class SkillResult(Enum):
    """Result of a skill execution step."""
    SUCCESS = auto()
    FAILURE = auto()
    SKIPPED = auto()
    NOT_APPLICABLE = auto()


@dataclass
class DiagnosticObject:
    """
    Standardized error description as defined in design.md Section 3.1.

    Attributes:
        uid: Unique identifier for this diagnostic.
        build_system: The build system that produced the error (e.g., 'soong', 'gn').
        error_code: The error code (e.g., 'C2039', 'E0020').
        location: A dict with 'file' and 'line' keys.
        symbol: The offending symbol (e.g., a function or variable name).
        raw_log: The original, unparsed log line.
    """
    uid: str
    build_system: str
    error_code: str
    location: Dict[str, Any]
    symbol: str
    raw_log: str


@dataclass
class ExecutionPlan:
    """
    Intermediate instruction generated by a skill, as per design.md Section 3.2.

    Attributes:
        version: Schema version.
        steps: A list of action dictionaries.
    """
    version: str = "1.0"
    steps: List[Dict[str, Any]] = field(default_factory=list)


class BaseSkill(ABC):
    """
    Abstract base class for all repair skills.

    Each skill must implement the lifecycle methods as defined in design.md Section 2.1:
    1. detect: Check if this skill is applicable to the given diagnostic.
    2. analyze: Gather context and confirm the error.
    3. pre_check: Validate the environment and file permissions.
    4. execute: Generate and apply the fix.
    5. verify: Run the build to confirm the fix works.
    """

    # Class-level attribute: error codes this skill handles
    error_codes: List[str] = []

    def __init__(self, name: str):
        self.name = name
        self.logger = get_logger(f"skill.{name}")

    @abstractmethod
    def detect(self, diagnostic: DiagnosticObject) -> bool:
        """
        Determine if this skill is applicable for the given diagnostic.

        Args:
            diagnostic: The standardized error object.

        Returns:
            True if this skill can handle the error, False otherwise.
        """
        pass

    @abstractmethod
    def analyze(self, diagnostic: DiagnosticObject, context: Any) -> Optional[Dict[str, Any]]:
        """
        Analyze the error context (e.g., search for symbols).

        Args:
            diagnostic: The standardized error object.
            context: The context engine instance for symbol lookup.

        Returns:
            A dict containing analysis results, or None if analysis fails.
        """
        pass

    def pre_check(self, diagnostic: DiagnosticObject, analysis_result: Dict[str, Any]) -> bool:
        """
        Verify environment before execution. Can be overridden.

        Default implementation returns True.
        """
        return True

    @abstractmethod
    def execute(self, diagnostic: DiagnosticObject, analysis_result: Dict[str, Any]) -> ExecutionPlan:
        """
        Generate the execution plan to fix the error.

        Args:
            diagnostic: The standardized error object.
            analysis_result: The result from the analyze step.

        Returns:
            An ExecutionPlan containing the steps to apply the fix.
        """
        pass

    def verify(self, diagnostic: DiagnosticObject) -> SkillResult:
        """
        Verify the fix by running an incremental build. Can be overridden.

        Default implementation returns SUCCESS.
        """
        return SkillResult.SUCCESS


class SkillManager:
    """
    Manages the registration, discovery, and lookup of skills.
    """

    def __init__(self):
        self._skills: Dict[str, Type[BaseSkill]] = {}
        self._error_code_index: Dict[str, List[Type[BaseSkill]]] = {}
        self.logger = get_logger(__name__)

    def register(self, skill_class: Type[BaseSkill]) -> None:
        """
        Register a skill class.

        Args:
            skill_class: The skill class to register.
        """
        skill_name = skill_class.__name__
        self._skills[skill_name] = skill_class
        self.logger.info(f"Registered skill: {skill_name}")

        # Index by error code
        for code in skill_class.error_codes:
            if code not in self._error_code_index:
                self._error_code_index[code] = []
            self._error_code_index[code].append(skill_class)
            self.logger.debug(f"Indexed skill {skill_name} for error code {code}")

    def get_skills_for_error(self, error_code: str) -> List[Type[BaseSkill]]:
        """
        Get all skills that can handle a given error code.

        Args:
            error_code: The error code to look up.

        Returns:
            A list of skill classes that are registered for this error code.
        """
        return self._error_code_index.get(error_code, [])

    def get_all_skills(self) -> Dict[str, Type[BaseSkill]]:
        """Return all registered skills."""
        return self._skills.copy()


# Global skill manager instance
skill_manager = SkillManager()


def register_skill(skill_class: Type[BaseSkill]) -> Type[BaseSkill]:
    """Decorator to register a skill class."""
    skill_manager.register(skill_class)
    return skill_class
